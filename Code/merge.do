clear all

local merge1           0
local merge2           1

if `merge1'==1 {

use "${root}/elections_clean.dta", clear
sort state year month
merge m:1 state using "${root}/term_limits_clean.dta"

// CONCATENATE STATE-LEGBRANCH-DISTRICT
egen unique_id=concat(state_abrv legbranch distr_id)
drop if sitting_legislator==0

sort unique_id year
egen unq_id_ele=concat(unique_id election_id)
bys unq_id_ele: gen counter=_n if _n==1
replace counter=sum(counter)
drop if candidate_fullname==""
cap save "${root}/master_dataset.dta", replace
}


if `merge2'==1   {
clear all
use "${root}/term_limited_elections.dta", clear
replace term_limited=0 if term_limited==.
replace term_limited=1 if term_limited==2

forval j=1/3 {

merge 1:1 caseid using  "${root}/names`j'.dta", gen(merge_`j')

}

replace limited_seat=0 if limited_seat==.
forval i=1/15{
  drop same`i' same_`i'
}

// drop single obs for which candidate name not known
drop if candidate_fullname==""

bys counter: egen limited_election=total(limited_seat) // gen election-level variable identifying if an election is a limited seat because the incumbent of that seat is term_limited and can't run
replace limited_election=1 if limited_election!=0       // taking care of cases when limited_election==2 because of multimember districts - now taken care of by fact that limited_election got generated by seat
replace same_lastname=0 if same_lastname==.

bys counter: egen incumbents_running=total(incumbent)
by counter: gen open_contest=1 if incumbents_running==0 & dis_type=="single"
by counter: replace open_contest=1 if incumbents_running<nr_cand & dis_type=="multim"
replace open_contest=0 if open_contest==.

// same measure as above but using alternative var for incumbent

bys counter: egen inc_running=total(alt_inc)
by counter: gen open=1 if inc_running==0 & dis_type=="single"
by counter: replace open=1 if inc_running<nr_cand & dis_type=="multim"
replace open=0 if open==.



// measures of nepotism / variables of interest
gen lastname_limited=same_lastname*limited_election
gen initial_limited=same_initial*limited_election
gen truncname_limited=same_truncname*limited_election

// fix issue with only 4 observations for which nr_cand=0
replace nr_cand=3 if counter==99180 & unique_id=="RI169."
replace nr_cand=1 if counter==102270 & unique_id=="SC180."

// replace nepotism=0 if candidate_fullname=="ROCCA, TORY" & state==22 & year==2004 & legbranch==1
// replace nepotism=1 if candidate_fullname=="CLARK, MARK" & state==3 & year==2000 & legbranch==1
// replace same_lastname=1 if candidate_fullname=="CLARK, MARK" & state==3 & year==2000 & legbranch==1

// create a series of dummy variables
gen unopposed=1 if nr_cand==1
replace unopposed=0 if unopposed==.

gen one_opponent=1 if nr_cand==2
replace one_opponent=0 if one_opponent==.

gen two_opponents=1 if nr_cand==3
replace two_opponents=0 if two_opponents==.

gen multiple_opponents=1 if nr_cand>3
replace multiple_opponents=0 if multiple_opponents==.

// drop unneccessary auxilliary vars
drop inc1 inc2 inc3 inc4 inc5 inc6 inc7 inc8 inc9 inc10 inc11 inc12 inc13 inc14 inc15 sum_same sum_inc merge_1 merge_2 merge_3

// gen var labels
label var unopposed "Unopposed"
label var one_opponent "One Opponent"
label var two_opponents "Two Opponents"
label var multiple_opponents "Multiple Opponents"
label var limited_election "Limited Election"
label var same_lastname "Same lastname"
label var same_truncname "Shares Lastname"
label var same_initial "middle name"
label var open_contest "Open Contest"
label var incumbents_running "Incumbents running"
label var lastname_limited "Same lastname x Limited"
label var truncname_limited "4 consec. str x Limited"
label var initial_limited "Middle name x Limited"

gen term_limits=1 if year>=yearenacted
replace term_limits=0 if term_limits==.

egen state_branch=concat(state legbranch)
destring state_branch, replace

cap save "${root}/analysis_dataset.dta", replace

}
